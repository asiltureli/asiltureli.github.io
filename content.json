{"posts":[{"title":"The correct way to use GMock with Catch2","text":"Hello World! In the last post I talked about the possible pitfalls of combining Catch2 with GMock. In this post I will go through the solution to this problem. Possible solutionsIf you stumbled upon this problem, you most probably made some research already. The useful result of this research for me was some Stackoverflow entries, an important inspiring repository and the Google Mock docs. The Google Mock documentation already mentions the issue and provides two solutions. The first, less elegant solution is to configure Google Mock to throw exceptions on failures. For me there are two problems here. The first one is already mentioned: throwing exceptions from the mock object’s destructor. The second problem (and question) is: what happens if I have multiple tests that fail in one section? Overall I directly passed that solution because the second one is way more beautiful. The second solution suggests to use the Google Test’s event listener API. As I was trying to implement the whole thing and digging into the source code of Catch2 and GMock, I realized this repository already provides an implementation. So. my rule of thumb is to skip reinventing the wheel. Instead, honor the original creator and seek ways to make their ideas even better. Overriding the GTest’s EventListener classThe idea is very simple. GTest follows the well known Observer Pattern and it maintains a singleton instance called listeners. This is a container to hold all listeners that are interested in a possible notification (error, warning etc.). When a notification arises, such as a failed test case, every listener is notified. In the next section I will deep-dive how this is achieved, but first a listener must be implemented, which connects the GMock/GTest and the Catch2. The goal of this listener is to create a Catch2 notification from the GMock notifications and pass it to Catch2. According to the documentation we must inherit a Listener from the EmptyEventListener class of GTest. EmptyEventListener is a great class, which provides virtual empty implementations for all EventListener methods, instead of leaving us with a dozen of pure virtual functions that are excited to be implemented. Therefore, we only need to implement the functions we need, which is in our case only OnTestPartResult.As a starting point, here is the implementation of the custom listener from the owner of the mentioned repository: 123456789101112131415161718192021222324252627282930313233343536class Listener : public testing::EmptyTestEventListener { void OnTestPartResult(const testing::TestPartResult&amp; result) override { std::string filename = &quot;unknown&quot;; size_t linenumber = 0; std::string message = &quot;unknown&quot;; if (result.file_name() != nullptr) filename = result.file_name(); if (result.line_number() != -1) linenumber = static_cast&lt;std::size_t&gt;(result.line_number()); if (result.message() != nullptr) message = result.message(); ::Catch::SourceLineInfo sourceLineInfo(filename.c_str(), linenumber); if (result.fatally_failed()) { ::Catch::AssertionHandler assertion(&quot;GTEST&quot;, sourceLineInfo, &quot;&quot;, ::Catch::ResultDisposition::Normal); assertion.handleMessage(::Catch::ResultWas::ExplicitFailure, message); assertion.complete(); } else if (result.nonfatally_failed()) { ::Catch::AssertionHandler assertion( &quot;GTEST&quot;, sourceLineInfo, &quot;&quot;, ::Catch::ResultDisposition::ContinueOnFailure); assertion.handleMessage(::Catch::ResultWas::ExplicitFailure, message); assertion.complete(); } } }; It has some problems which we will be fixing but it is a great starting point. The code is very understandable: GTest notifies us with a TestPartResult&amp; result which contains information like file name, line number and the message. Depending on the error type we create either a Normal assertion or a ContinueOnFailure assertion and process it in a Catch2-way. But what are the problems in that code? There are two problems, one of them is obvious and the second one is a very sneaky one (Hint: const char*). The code only works for Catch2 v2. It required some adaptations for different versions. For example assertion.setCompleted() is from major version 2, which is changed to assertion.completed() in the version 3. Or another issue is that assertion.handleMessage is expecting the message as an r-value reference starting from the version v3.7.1 with the related commit. This code must be tested and adapted for each Catch2 version. This is actually a very hard to see issue. The problem is at the constructor of the AssertionHandler. We create a local variable filename and pass the const char* of that variable to the constructor. However we don’t have any information what assertion is doing with our pointer. Eventually the usage might outlive the filename. The solution for this is to create a member-container that holds the filename for each notification. This way we can assure that the string is always there, since the listener is destroyed at the end of the program. After solving these issues our code looks like the following: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Listener : public testing::EmptyTestEventListener { std::set&lt;std::string&gt; m_file_names; // Solution to 2. void OnTestPartResult(const testing::TestPartResult&amp; result) override { std::string filename = &quot;unknown&quot;; size_t linenumber = 0; std::string message = &quot;unknown&quot;; if (result.file_name()) filename = result.file_name(); if (result.line_number() != -1) linenumber = static_cast&lt;std::size_t&gt;(result.line_number()); if (result.message()) message = result.message(); auto [it, _] = m_file_names.insert(filename); // Solution to 2. ::Catch::SourceLineInfo sourceLineInfo(it-&gt;c_str(), linenumber); // Solution to 2. if (result.fatally_failed()) { ::Catch::AssertionHandler assertion( &quot;GMock&quot;, sourceLineInfo, &quot;&quot;, ::Catch::ResultDisposition::Normal); assertion.handleMessage(::Catch::ResultWas::ExplicitFailure, std::move(message)); // Solution to 1. assertion.complete(); // Solution to 1. } else if (result.nonfatally_failed()) { ::Catch::AssertionHandler assertion( &quot;GMock&quot;, sourceLineInfo, &quot;&quot;, ::Catch::ResultDisposition::ContinueOnFailure); assertion.handleMessage(::Catch::ResultWas::ExplicitFailure, std::move(message)); // Solution to 1. assertion.complete(); // Solution to 1. } }}; The changes we apply include adding the m_file_names variable, the version specific assertion.complete and the changed signature of the assertion.handleMessage function. Be aware that this signature is only valid starting from v3.7.1. Adding the custom Listener to the GTest’s listenersIn the last section we created our own GTest listener, which will notify the Catch2 about the failing GMock checks. But we also need to make sure that GTest knows that we want him to notify our listener instead of some other listener object. For this purpose we will replace the default GTest listener with our listener. Here is a main that would solve this problem according to the event listener API : 123456789101112int main(int argc, char** argv){ Catch::Session session; InitGoogleMock(&amp;argc, argv); TestEventListeners&amp; gtest_listeners = UnitTest::GetInstance()-&gt;listeners(); gtest_listeners.Append(new GTestCatch2Listener()); delete gtest_listeners.Release( UnitTest::GetInstance()-&gt;listeners().default_result_printer()); return session.run(argc, argv);} This code achieves a very simple task. It deletes the default listener from GTest, attaches our custom listener and passes the command line arguments to GMock and Catch2. With this main and the listener it is now safe to combine GMock and Catch2. We can verify this with a new test: SummaryIf you have made so far, thank you for reading. In this post I introduced a way to connect GMock and Catch2. However it is still not the best solution. In the next post I will be creating a library which acts as Catch2WithMain which provides a pre-compiled main and works correctly with GMock. This way we will be able to use GMock and Catch2 only by linking against this new library. The code for this post can be found here Cheers.","link":"/2024/11/26/gmockcatch2adapter/"},{"title":"The danger of combining GMock with Catch2","text":"Recently I stumbled upon a problem at work while writing unit tests. The unit tests I wrote were not failing even though they were supposed to fail. At first, I thought I had made a mistake in my mock classes, but the issue turned out to be completely different. Catch2 is a great BDD (Behavior Driving Development) framework for C++, however it lacks a main functionality; Mocking. Therefore it would be useful to deploy GMock at this point. However this comes with a great danger. In this post I want to write about the danger and possible pitfall of combining GMock with Catch2 or possibly any other unit testing framework. One might thing: why not GoogleTest? The question is understandable but GTest does not offer BDD. It is designed to write TDD tests. Therefore it is a combination, which makes completely sense. I will share the complete code in my repository. Writing a very basic mockLet’s start with a very basic class and the mock for this class: 12345678910class ClassToTest{public: virtual void some_call(){};};class MockClass : public ClassToTest{public: MOCK_METHOD(void, some_call, (), (override));}; This should be pretty straightforward. We have a class we want to test, ClassToTest, and the corresponding mock class, MockClass. Now, let’s add a caller for that class: 12345678class SimpleWrapper{public: SimpleWrapper() = delete; SimpleWrapper(ClassToTest&amp; sc) : m_obj { sc }{}; void call(){m_obj.some_call();};private: ClassToTest&amp; m_obj;}; The SimpleWrapper takes an ClassToTest as reference and allows us to call its some_call method. Now we are ready to test our class. Writing and running some tests in Catch2In this phase we can write some tests to check our class with Catch2. Here are some very minimal tests: 1234567891011121314151617using namespace ::testing;TEST_CASE(&quot;Strict Mock Test&quot;){ auto mock = StrictMock&lt;MockClass&gt;(); auto caller = SimpleWrapper(mock); caller.call();}TEST_CASE(&quot;Expect call&quot;){ auto mock = NiceMock&lt;MockClass&gt;(); auto caller = SimpleWrapper(mock); EXPECT_CALL(mock, some_call()).Times(100); caller.call();} In the first test case we define a StrictMock and don’t set any expectations. However we call our function through our SimpleWrapper. The strict mock should report us the unexpected e.g. uninteresting call as an error. Therefore this is obviously a failed test case. In the second test case, we define a NiceMock, which doesn`t affect our test case in terms of unexpected calls. The goal here is to set an expectation on some_call. We expect that our function gets called 100 times within this scope. However, we call it only once. This is, again, an obvious failed test case. Running the testLets run our tests, which should obviously fail: This result is interesting and not what we would expect or want. Let’s simple run and see the output of our executable: The result is still the same however we can see that something is odd. Here’s what happens: we are using the precompiled main() of Catch2, which simply looks something like: 1234// Simplified from catch2/src/catch2/internal/catch_main.cppint main (int argc, char * argv[]) { return Catch::Session().run( argc, argv );} That means we are getting the result of our tests from Catch2::Session. However the question is: does Catch2 recognize that GMock/GTest expressions are failing? The answer is NO!. The tests that are being conducted by Googletest must be passed to the Catch2. And Googletest developers have addressed this issue: Using Google Mock with Any Testing Framework TLDR: If you want to use GMock with other testing frameworks, it must be fine-tuned. This issue is pretty obvious and straightforward after reading about it or figuring it out. However, it’s a really painful problem that will most likely cause someone to spend days trying to understand what’s happening without knowing the root cause. Summary Catch2 and GMock together form a very strong testing combination. However they do not work together out of the box. This might trick you into pushing a buggy code into the production. Thank you for reading. The source code for this post can be found here In the next post, I will go into detail on how to solve this issue.","link":"/2024/11/22/gmockcatch2danger/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[],"pages":[{"title":"About","text":"About meI am currently a Software Developer at Rohde &amp; Schwarz Cybersecurity in Berlin, participating in the development of Layer-2 based network encryption systems for protecting govermental and critical infrastructures. My previous work at other companies and current work mainly consist of the C++ components and the build/meta-build system(CMake). But I also want to get my hands dirty with our linux kernel later. Outside of the work I try to try out new technologies and implement the existing stack from scratch. This website mostly serves as a diary to share the things I am working on in my free time. If you want to ask/discuss about anything I share or contact me for any reason, you can always reach via Linkedin. You can also listen to my music on my Soundcloud account.","link":"/about/index.html"}]}